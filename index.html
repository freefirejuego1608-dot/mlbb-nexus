<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cronopirata</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
  <style>
    body { margin:0; padding:0; background:#000; overflow:hidden; font-family:Arial; }
    #ui { position:absolute; top:10px; left:10px; color:#fff; z-index:100; }
    #log { position:absolute; bottom:10px; left:10px; color:#0f0; font-size:12px; max-height:100px; overflow-y:auto; }
  </style>
</head>
<body>
  <div id="ui">Oro: <span id="gold">0</span> | Vida: <span id="hp">100</span> | LÃ­nea: <span id="line">1</span></div>
  <div id="log"></div>
  <script type="module">
    // === CONFIGURACIÃ“N GLOBAL ===
    const CONFIG = {
      SERVER: 'wss://cronopirata-server.onrender.com', // Cambiar por tu servidor real
      PLAYER_ID: 'player_' + Math.random().toString(36).substr(2,9),
      LINE_ID: null,
      WORLD_SEED: Math.random()
    };

    // === ESTADO LOCAL ===
    let gameState = {
      gold: 50,
      hp: 100,
      x: 400, y: 300,
      vx: 0, vy: 0,
      angle: 0,
      line: 1,
      ghosts: [], // LÃ­neas temporales muertas
      particles: []
    };

    // === WEB SOCKET (SIMULADO PARA GITHUB) ===
    class FakeWS {
      constructor() { this.listeners = {}; }
      on(event, cb) { this.listeners[event] = cb; }
      send(data) { 
        addLog(`ðŸ“¤ ${data}`);
        setTimeout(() => this.simulateResponse(JSON.parse(data)), 500);
      }
      simulateResponse(msg) {
        if (msg.type === 'join') {
          CONFIG.LINE_ID = msg.line || Date.now();
          this.listeners.message({data: JSON.stringify({type:'init', ...gameState, line: CONFIG.LINE_ID})});
        }
        if (msg.type === 'move') {
          this.listeners.message({data: JSON.stringify({type:'ghost', id:msg.id, x:msg.x, y:msg.y, angle:msg.angle})});
        }
      }
    }
    const ws = new FakeWS(); // En producciÃ³n: new WebSocket(CONFIG.SERVER)

    // === PHASER GAME ===
    const config = {
      type: Phaser.AUTO,
      width: 800, height: 600,
      physics: { default: 'arcade', arcade: { debug: false } },
      scene: { preload, create, update },
      parent: 'phaser-game'
    };
    const game = new Phaser.Game(config);

    function preload() {
      this.load.image('ship', 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0zMiAzMk0yNiAyMmgxMmwxLTN6TTI0IDI2bDEuNS0zaDEuNWwxLjUtM2gzbDEuNS0zaDFsMS41IDNoM2wxLjUgM2gxLjVsMS41IDNoMWwxIDN6IiBmaWxsPSIjZmY5OTAwIi8+PHBhdGggZD0iTTI4IDM0bDItMmg4bC0yLTJ6IiBmaWxsPSIjY2MwMDAwIi8+PC9zdmc+');
      this.load.image('island', 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgZmlsbD0iIzY2Nj633IiByeD0iNSIvPjxjaXJjbGUgY3g9IjI1IiBjeT0iMjUiIHI9IjE1IiBmaWxsPSIjODg4ODg4Ii8+PC9zdmc+');
      this.load.image('treasure', 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIzMCIgaGVpZ2h0PSIzMCIgZmlsbD0iI2ZmY2MwMCIvPjx0ZXh0IHg9IjE1IiB5PSIyMCIgZm9udC1zaXplPSIxOCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzAwMCI+JDwvdGV4dD48L3N2Zz4=');
      this.load.image('particle', 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxjaXJjbGUgY3g9IjQiIGN5PSI0IiByPSI0IiBmaWxsPSJ5ZWxsb3ciLz48L3N2Zz4=');
    }

    let player, islands, treasures, ghosts, particles, cursors, spaceKey;

    function create() {
      this.cameras.main.setBackgroundColor('#003366');

      // Grupos
      islands = this.physics.add.staticGroup();
      treasures = this.physics.add.staticGroup();
      ghosts = this.physics.add.group();
      particles = this.add.particles(0, 0, 'particle', {
        speed: 100, lifespan: 500, quantity: 3, scale: { start: 1, end: 0 }, blendMode: 'ADD'
      });
      particles.stop();

      // Jugador
      player = this.physics.add.image(400, 300, 'ship').setScale(0.8).setDepth(10);
      player.setCollideWorldBounds(true);

      // Controles
      cursors = this.input.keyboard.createCursorKeys();
      spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

      // Generar mundo procedural (fragmentos de lÃ­neas muertas)
      generateWorld(this, CONFIG.WORLD_SEED);

      // Colisiones
      this.physics.add.collider(player, islands, hitIsland, null, this);
      this.physics.add.overlap(player, treasures, collectTreasure, null, this);
      this.physics.add.overlap(player, ghosts, raidGhost, null, this);

      // UI
      this.goldText = this.add.text(10, 10, '', {font: '16px Arial', color: '#ff0'}).setDepth(100);
      this.hpText = this.add.text(10, 30, '', {font: '16px Arial', color: '#f00'}).setDepth(100);
      this.lineText = this.add.text(10, 50, '', {font: '16px Arial', color: '#0ff'}).setDepth(100);

      // WebSocket
      ws.on('message', (e) => handleMessage(JSON.parse(e.data), this));
      ws.send(JSON.stringify({type: 'join', id: CONFIG.PLAYER_ID}));
    }

    function update() {
      const speed = 180;
      const turn = 4;

      // Movimiento
      if (cursors.left.isDown) gameState.angle -= turn;
      if (cursors.right.isDown) gameState.angle += turn;
      if (cursors.up.isDown) {
        gameState.vx = Math.cos(gameState.angle * Math.PI / 180) * speed;
        gameState.vy = Math.sin(gameState.angle * Math.PI / 180) * speed;
        particles.emitParticleAt(player.x, player.y, 3);
      } else {
        gameState.vx *= 0.95; gameState.vy *= 0.95;
      }

      player.setVelocity(gameState.vx, gameState.vy);
      player.setRotation(gameState.angle * Math.PI / 180);

      gameState.x = player.x; gameState.y = player.y;

      // Enviar posiciÃ³n
      if (Math.random() < 0.1) {
        ws.send(JSON.stringify({
          type: 'move',
          id: CONFIG.PLAYER_ID,
          line: CONFIG.LINE_ID,
          x: player.x,
          y: player.y,
          angle: gameState.angle
        }));
      }

      // Abandonar lÃ­nea (ESPACIO)
      if (spaceKey.isDown && !this.spaceDown) {
        this.spaceDown = true;
        abandonLine(this);
      } else if (spaceKey.isUp) {
        this.spaceDown = false;
      }

      updateUI(this);
    }

    // === GENERACIÃ“N DE MUNDO ===
    function generateWorld(scene, seed) {
      const rng = new Phaser.Math.RandomDataGenerator([seed.toString()]);
      for (let i = 0; i < 8; i++) {
        const x = rng.between(100, 700);
        const y = rng.between(100, 500);
        const island = islands.create(x, y, 'island').setScale(rng.between(80, 150)/100).setTint(0x666633);
        island.body.setCircle(25);
        island.lineOwner = 'ghost_' + i;
        island.gold = rng.between(20, 80);
      }
      for (let i = 0; i < 5; i++) {
        const x = rng.between(50, 750);
        const y = rng.between(50, 550);
        treasures.create(x, y, 'treasure').setScale(0.6);
      }
    }

    // === INTERACCIONES ===
    function hitIsland(player, island) {
      gameState.hp -= 5;
      addLog(`ðŸï¸ Choque con isla de ${island.lineOwner}! -5 HP`);
      if (gameState.hp <= 0) die(this.scene);
    }

    function collectTreasure(player, treasure) {
      treasure.destroy();
      gameState.gold += 25;
      addLog(`ðŸ’° +25 oro! Total: ${gameState.gold}`);
      particles.emitParticleAt(treasure.x, treasure.y, 10);
    }

    function raidGhost(player, ghost) {
      const loot = Math.floor(Math.random() * 50);
      gameState.gold += loot;
      addLog(`ðŸ‘» Saqueaste lÃ­nea muerta! +${loot} oro`);
      ghost.destroy();
    }

    function abandonLine(scene) {
      addLog(`â³ Abandonando lÃ­nea temporal ${CONFIG.LINE_ID}...`);
      ws.send(JSON.stringify({
        type: 'abandon',
        id: CONFIG.PLAYER_ID,
        line: CONFIG.LINE_ID,
        gold: gameState.gold,
        x: player.x,
        y: player.y
      }));
      // Reiniciar en nueva lÃ­nea
      gameState.line++;
      gameState.gold = 50;
      gameState.hp = 100;
      player.setPosition(400, 300);
      islands.clear(true, true);
      treasures.clear(true, true);
      ghosts.clear(true, true);
      generateWorld(scene, Math.random());
      addLog(`â° Nueva lÃ­nea temporal #${gameState.line}!`);
    }

    function die(scene) {
      addLog(`ðŸ’€ Â¡MUERTE EN LÃNEA ${CONFIG.LINE_ID}! Tu mundo ahora es saqueable.`);
      abandonLine(scene);
    }

    // === COMUNICACIÃ“N ===
    function handleMessage(msg, scene) {
      if (msg.type === 'init') {
        gameState = {...gameState, ...msg};
        CONFIG.LINE_ID = msg.line;
      }
      if (msg.type === 'ghost' && msg.line !== CONFIG.LINE_ID) {
        let ghost = ghosts.get(msg.x, msg.y, 'ship');
        if (ghost) {
          ghost.setActive(true).setVisible(true).setTint(0xff0000).setAlpha(0.6);
          ghost.lineOwner = msg.id;
          ghost.setScale(0.7);
        }
      }
    }

    // === UI & LOG ===
    function updateUI(scene) {
      document.getElementById('gold').textContent = gameState.gold;
      document.getElementById('hp').textContent = gameState.hp;
      document.getElementById('line').textContent = gameState.line;
    }

    function addLog(text) {
      const log = document.getElementById('log');
      const line = document.createElement('div');
      line.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
      log.appendChild(line);
      log.scrollTop = log.scrollHeight;
    }

    // === SERVIDOR NODE.JS (server.js) ===
    const serverCode = `
/*
  CRONOPIRATA SERVER - Sube esto a Render.com / Railway / Fly.io
  Archivo: server.js
*/
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: process.env.PORT || 8080 });

const lines = {}; // { lineId: { gold, owner, x, y } }
const ghosts = new Set();

wss.on('connection', ws => {
  ws.on('message', data => {
    const msg = JSON.parse(data);
    if (msg.type === 'join') {
      const lineId = msg.line || Date.now().toString();
      ws.send(JSON.stringify({ type: 'init', line: lineId }));
    }
    if (msg.type === 'move') {
      // Broadcast como fantasma a otras lÃ­neas
      wss.clients.forEach(client => {
        if (client !== ws && client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({ type: 'ghost', ...msg }));
        }
      });
    }
    if (msg.type === 'abandon') {
      lines[msg.line] = { gold: msg.gold, owner: msg.id, x: msg.x, y: msg.y };
      ghosts.add(msg.line);
    }
  });
});

console.log('Cronopirata Server ON - Puerto:', process.env.PORT || 8080);
    `.trim();

    // === ARCHIVO README.md ===
    const readme = `
# Cronopirata ðŸ•°ï¸ðŸ´â€â˜ ï¸

**Juego web roguelite de paradojas temporales - 100% funcional en GitHub Pages + Servidor**

## ðŸš€ Demo (GitHub Pages)
[https://TU_USUARIO.github.io/cronopirata](https://TU_USUARIO.github.io/cronopirata)

## ðŸ“‚ Estructura
\`\`\`
cronopirata/
â”œâ”€â”€ index.html          â† Juego completo
â”œâ”€â”€ server.js           â† Servidor Node.js (Render/Railway)
â””â”€â”€ README.md
\`\`\`

## ðŸ› ï¸ Deploy RÃ¡pido

### 1. GitHub Pages (Cliente)
 `gh repo clone TU_USUARIO/cronopirata && cd cronopirata`
 Sube \`index.html\` â†’ GitHub Pages activado.

### 2. Servidor (Gratis en Render.com)
1. Crea cuenta en [render.com](https://render.com)
2. New â†’ Web Service â†’ Pegar \`server.js\`
3. Cambia en \`index.html\`:  
   \`const SERVER = 'wss://TU-SERVICIO.onrender.com';\`
4. Â¡Listo! Multijugador asÃ­ncrono activo.

## ðŸŽ® Controles
- **Flechas**: Girar / Acelerar
- **Espacio**: Abandonar lÃ­nea temporal

## âš¡ MecÃ¡nicas
- Muere â†’ tu mundo se vuelve saqueable
- Saquea islas de lÃ­neas muertas
- Venganza: viaja al pasado y destruye al que te robÃ³

## ðŸ’¡ PrÃ³ximos pasos
- [ ] Guardar lÃ­neas en IndexedDB
- [ ] Skins con Three.js
- [ ] Paradojas reales (borrar muertes)

**Â¡Navega por los restos del multiverso pirata!**
    `.trim();

    // === DESCARGA AUTOMÃTICA ===
    function download(filename, text) {
      const el = document.createElement('a');
      el.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
      el.setAttribute('download', filename);
      el.style.display = 'none';
      document.body.appendChild(el);
      el.click();
      document.body.removeChild(el);
    }

    // Descargar todo
    setTimeout(() => {
      download('index.html', document.documentElement.outerHTML);
      download('server.js', serverCode);
      download('README.md', readme);
      addLog('ðŸ“¦ Â¡Archivos generados! Descarga: index.html, server.js, README.md');
      addLog('ðŸš€ Sube a GitHub + Render.com â†’ Â¡Juego online en 5 min!');
    }, 1000);

  </script>
</body>
</html>
